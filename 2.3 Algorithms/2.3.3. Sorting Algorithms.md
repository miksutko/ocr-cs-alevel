Tags: #node 
# 1. Bubble Sort
**Positives**:
- Very simple to understand and implement, good for teaching basic algorithmic ideas.
- In-place sorting, does not require extra memory.
- Can terminate early (with the improved version using a swap flag).
- Works well on very small datasets or nearly sorted data (with optimisation).
**Negatives**:
- Very slow for large datasets, time complexity O(n²).
- Makes many unnecessary comparisons, especially in the basic version.
- Inefficient even when mostly sorted unless optimisation is used.
- Rarely used in real-world applications.
## Pseudocode:
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:
            break
```
<iframe width="560" height="315" src="https://www.youtube.com/embed/hahrx5WUeNI?si=nODpgaG78ygTKYRo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
# 2. Insertion Sort
**Positives**:
- Simple and intuitive logic.
- In-place, low memory usage.
- Efficient for small datasets.
- Very efficient for nearly sorted data (much faster than bubble sort).
- Often used as a subroutine in more complex algorithms.
**Negatives**:
- O(n²) time complexity in the worst case.
- Still slow for large, randomly ordered datasets.
- Performance heavily depends on the initial order of elements.
## Pseudocode:
``` python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >=0 and arr[j] > key:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
```
<iframe width="560" height="315" src="https://www.youtube.com/embed/JU767SDMDvA?si=wY0N9iK8GexYLNa-" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
# 3. Merge Sort
Positives:
- Much faster than bubble and insertion sort.
- Guaranteed time complexity of O(n log n).
- Stable sort (preserves order of equal elements).
- Very effective for large datasets.
- Well suited to linked lists and external sorting (e.g. files).
**Negatives**:
- Not in-place → requires additional memory.
- More complex to implement and understand.
- Overhead makes it less efficient than simpler algorithms for very small datasets.

<iframe width="560" height="315" src="https://www.youtube.com/embed/5Z9dn2WTg9o?si=JZWuZUDHMe7D28p6" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
# 4. Quick Sort
**Positives**:
- Very fast in practice (often faster than merge sort).
- In-place → memory efficient.
- Works well for large datasets.
- Good cache performance due to locality of reference.
**Negatives**:
- Worst-case time complexity of O(n²).
- Performance depends heavily on pivot selection.
- Not stable.
- Recursive calls can cause stack overflow if poorly implemented.

<iframe width="560" height="315" src="https://www.youtube.com/embed/WprjBK0p6rw?si=x98weue6aJhp_HoT" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
# Comparative Overview
| Algorithm      | Time Complexity             | Space Complexity | Stable? | Key Feature             |
| -------------- | --------------------------- | ---------------- | ------- | ----------------------- |
| Bubble Sort    | O(n²)                       | O(1)             | Yes     | Simple, inefficient     |
| Insertion Sort | O(n²)                       | O(1)             | Yes     | Good for small datasets |
| Merge Sort     | O(n log n)                  | O(n)             | Yes     | Divide & conquer        |
| Quick Sort     | O(n²) worst, O(n log n) avg | O(log n)         | No      | Fast in practice        |
Time Complexity: This measures how the execution time (the number of computational steps) of an algorithm scales as the input size grows
Space Complexity: This measures the total memory usage required by an algorithm to run to completion as a function of the input size.

![[Pasted image 20260209095727.png]]
