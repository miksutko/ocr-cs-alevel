Tags: #node 
# Dijkstra’s Algorithm
**Positives**:
- Guaranteed to find the shortest path (if all edge weights are non-negative).
- Works for any weighted graph (directed or undirected).
- Predictable and reliable.
- Efficient compared to brute force approaches.
- Time complexity:
    - O(V²) (simple implementation)
    - O((V + E) log V) with a priority queue
- Widely used in:
    - Network routing
    - GPS systems
    - Packet forwarding
**Negatives**:
- Cannot handle negative edge weights.
- May explore many unnecessary nodes.
- Can be slower than A* when a heuristic is available.
- Requires extra data structures (e.g. priority queue).    
- Computational cost increases significantly for very large graphs.

<iframe width="560" height="315" src="https://www.youtube.com/embed/_lHSawdgXpI?si=QTHQ6Y0jZC5A-_qV" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
# **A* Algorithm**
**Positives**:
- Usually **faster than Dijkstra’s algorithm**.
- Uses a **heuristic** to guide the search.
- Explores fewer nodes in many cases.
- Still guarantees the shortest path **if the heuristic is admissible** (never overestimates).
- Very effective for:
    - Pathfinding in games
    - Navigation systems
    - Robotics
**Negatives**:
- Effectiveness depends heavily on the quality of the heuristic.
- Poor heuristic → performance similar to Dijkstra.
- More complex to implement.
- May not guarantee optimal path if heuristic is not admissible.    
- Requires additional memory to store heuristic values.

<iframe width="560" height="315" src="https://www.youtube.com/embed/zycfu79Y8Fw?si=dSXnZ9K9uKMlsPEd" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>