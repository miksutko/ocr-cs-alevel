Tags: #node 
# 1. Stacks
**Positives**:
- Simple FILO (First In, Last Out) structure.
- All main operations (push, pop, peek, isEmpty, size) are O(1).
- Easy to implement using arrays.
- Useful for:
    - Function calls (call stack)
    - Undo/redo systems
    - Expression evaluation
- Low memory overhead (single pointer).
**Negatives**:
- Access limited to top element only.
- No random access.
- Can overflow if fixed-size array is used.
- Not suitable when data must be accessed in arbitrary order.
# 2. Queues
**Positives**:
- FIFO (First In, First Out) structure.
- Operations (enqueue, dequeue, peek) are O(1).
- Models real-world systems (waiting lines, scheduling).
- Efficient for:
    - Task scheduling
    - Breadth-first search
    - Buffering data streams
- Simple logic using front and back pointers.
**Negatives**:
- No random access.
- Can waste space in simple array implementation (unless circular queue).
- Fixed-size queues can overflow.
- Slightly more complex than stacks (two pointers).
# 3. Linked Lists
**Positives**:
- Dynamic size (no fixed capacity).
- Efficient insertion/deletion at head (O(1)).
- Memory allocated as needed.
- No shifting of elements required (unlike arrays).
**Negatives**:
- Searching is O(n) (requires linear traversal).
- No direct indexing (must follow pointers).
- Extra memory needed for pointers.
- Poor cache performance compared to arrays.
# 4. Trees & Traversals

## Traversal Methods:
### Depth-First (Post-Order)
**Order**: Left → Right → Root  
**Positives**:
- Uses less memory than BFS in many cases.
- Good for exploring complete paths.
- Useful for:
    - Evaluating expression trees
    - Deleting trees
- Stack-based (can be recursive).
**Negatives**:
- May go deep into unnecessary branches.
- Not guaranteed to find shortest path in general trees.
- Recursive implementation risks stack overflow.
### Breadth-First Search
**Order**: Level by Level  
**Positives**:
- Explores level by level.
- Finds **shortest path in unweighted trees/graphs**.
- Systematic and easy to understand.
- Queue-based implementation.
**Negatives**:
- Can use large amounts of memory (stores entire level).
- Slower than DFS when searching deep nodes.
- Less efficient for very wide trees.
# Comparative Analysis
| Structure / Algorithm | Strength            | Weakness               | Best Used For            |
| --------------------- | ------------------- | ---------------------- | ------------------------ |
| Stack                 | Fast top access     | Limited access         | Undo systems, recursion  |
| Queue                 | Order preservation  | No random access       | Scheduling, BFS          |
| Linked List           | Dynamic size        | Slow search            | Frequent insert/delete   |
| DFS                   | Memory efficient    | May explore wrong path | Deep exploration         |
| BFS                   | Finds shortest path | High memory use        | Level-by-level traversal |
