Tags: #node 
# 1. Binary Search
**Positives**:
- Very efficient → time complexity O(log n).
- Discards half of the remaining data with each comparison.
- Scales extremely well for large datasets.
- Predictable performance.
- Widely used in real systems (e.g. searching databases, indexes).
**Negatives**:
- Requires data to be sorted beforehand.
- Sorting introduces extra time overhead if data is unsorted.
- More complex to implement than linear search.
- Less flexible when data changes frequently (insertions break order).
## Pseudocode:
```python
low = 0  
high = A.length -1  
while low <= high:  
	mid = (low + high) / 2  
	if A[mid] == x:  
		return mid  
	else if A[mid] > x:  
		high = mid -1  
	else:  
		low = mid + 1  
	endif  
endwhile  
return “Not found in data”
```

<iframe width="560" height="315" src="https://www.youtube.com/embed/fDKIpRe8GW4?si=IeNpbqBkl8HhGKY7" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
# 2. Linear Search
**Positives**:
- Very simple to understand and implement.
- Works on unsorted data.
- No preprocessing required.
- Useful for small datasets.
- Can terminate early if the item is near the start.
**Negatives**:
- Inefficient for large datasets → time complexity O(n).
- Performance depends heavily on position of the target value.
- Worst-case scenario requires checking every element.
- Not suitable for performance-critical applications.
## Pseudocode:
```python
i = 0  
while i < A.length:  
	if A[i] == x:  
		return i  
	else:  
		i = i + 1  
	endif  
endwhile  
return “Not found in data”
```

<iframe width="560" height="315" src="https://www.youtube.com/embed/246V51AWwZM?si=sP8UjNX_lRkE3hPQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
# Comparative Analysis

| Feature                       | Linear Search          | Binary Search      |
| ----------------------------- | ---------------------- | ------------------ |
| Data must be sorted           | No                     | Yes                |
| Worst-case time complexity    | O(n)                   | O(log n)           |
| Implementation difficulty     | Very easy              | Moderate           |
| Performance on large datasets | Poor                   | Excellent          |
| Best use case                 | Small or unsorted data | Large, sorted data |
